# DevOps

DevOps is a set of practices that works to automate and integrate the processes between software development and IT teams, so they can build, test, and release software faster and more reliably.The term DevOps was formed by combining the words “development” and “operations”. As its name suggests, it seeks to bridge the gap between development and operation teams, which historically functioned in siloes. The concept of DevOps was founded on building a culture of collaboration between teams that historically functioned in siloes.

![](.gitbook/assets/image%20%2830%29.png)

**At its essence, DevOps is a culture, a movement, a philosophy.**

It's a firm handshake between development and operations that emphasizes a shift in mindset, better collaboration, and tighter integration. It unites [agile](https://www.atlassian.com/agile), [git](https://www.atlassian.com/git/tutorials/what-is-git), [continuous delivery](https://www.atlassian.com/continuous-delivery/principles), automation, and much more, to help development and operations teams be more efficient, innovate faster, and deliver higher value to businesses and customers.



## test driven development process

**Test-driven development** \(**TDD**\) is a [software development process](https://en.wikipedia.org/wiki/Software_development_process) that relies on the repetition of a very short development cycle: requirements are turned into very specific [test cases](https://en.wikipedia.org/wiki/Test_case), then the code is improved so that the tests pass. This is opposed to software development that allows code to be added that is not proven to meet requirements.

![](.gitbook/assets/image%20%2877%29.png)

**1**. Add a testIn test-driven development, each new feature begins with writing a test. Write a test that defines a function or improvements of a function, which should be very succinct. To write a test, the developer must clearly understand the feature's specification and requirements. The developer can accomplish this through [use cases](https://en.wikipedia.org/wiki/Use_case) and [user stories](https://en.wikipedia.org/wiki/User_story) to cover the requirements and exception conditions, and can write the test in whatever testing framework is appropriate to the software environment. It could be a modified version of an existing test. This is a differentiating feature of test-driven development versus writing unit tests after the [code](https://en.wikipedia.org/wiki/Source_code) is written: it makes the developer focus on the requirements before writing the code, a subtle but important difference.

2. Run all tests and see if the new test failsThis validates that the [test harness](https://en.wikipedia.org/wiki/Test_harness) is working correctly, shows that the new test does not pass without requiring new code because the required behavior already exists, and it rules out the possibility that the new test is flawed and will always pass. The new test should fail for the expected reason. This step increases the developer's confidence in the new test.

3. Write the codeThe next step is to write some code that causes the test to pass. The new code written at this stage is not perfect and may, for example, pass the test in an inelegant way. That is acceptable because it will be improved and honed in Step 

5.At this point, the only purpose of the written code is to pass the test. The programmer must not write code that is beyond the functionality that the test checks.

4. Run testsIf all test cases now pass, the programmer can be confident that the new code meets the test requirements, and does not break or degrade any existing features. If they do not, the new code must be adjusted until they do.5. Refactor codeThe growing code base must be [cleaned up](https://en.wikipedia.org/wiki/Code_refactoring) regularly during test-driven development. New code can be moved from where it was convenient for passing a test to where it more logically belongs. [Duplication](https://en.wikipedia.org/wiki/Duplicate_code) must be removed. [Object](https://en.wikipedia.org/wiki/Object_%28computer_science%29), [class](https://en.wikipedia.org/wiki/Class_%28computer_programming%29), [module](https://en.wikipedia.org/wiki/Modular_programming), [variable](https://en.wikipedia.org/wiki/Variable_%28computer_science%29) and [method](https://en.wikipedia.org/wiki/Method_%28computer_programming%29) names should clearly represent their current purpose and use, as extra functionality is added. As features are added, method bodies can get longer and other objects larger. They benefit from being split and their parts carefully named to improve [readability](https://en.wikipedia.org/wiki/Computer_programming#Readability_of_source_code) and [maintainability](https://en.wikipedia.org/wiki/Software_maintenance), which will be increasingly valuable later in the [software lifecycle](https://en.wikipedia.org/wiki/Software_lifecycle). [Inheritance hierarchies](https://en.wikipedia.org/wiki/Inheritance_%28object-oriented_programming%29) may be rearranged to be more logical and helpful, and perhaps to benefit from recognized [design patterns](https://en.wikipedia.org/wiki/Software_design_pattern). There are specific and general guidelines for refactoring and for creating clean code.[\[6\]](https://en.wikipedia.org/wiki/Test-driven_development#cite_note-6)[\[7\]](https://en.wikipedia.org/wiki/Test-driven_development#cite_note-7) By continually re-running the test cases throughout each refactoring phase, the developer can be confident that process is not altering any existing functionality.The concept of removing duplication is an important aspect of any software design. In this case, however, it also applies to the removal of any duplication between the test code and the production code—for example [magic numbers](https://en.wikipedia.org/wiki/Magic_number_%28programming%29) or strings repeated in both to make the test pass in Step 3.RepeatStarting with another new test, the cycle is then repeated to push forward the functionality. The size of the steps should always be small, with as few as 1 to 10 edits between each test run. If new code does not rapidly satisfy a new test, or other tests fail unexpectedly, the programmer should [undo](https://en.wikipedia.org/wiki/Undo) or revert in preference to excessive [debugging](https://en.wikipedia.org/wiki/Debugging). [Continuous integration](https://en.wikipedia.org/wiki/Continuous_integration) helps by providing revertible checkpoints. When using external libraries it is important not to make increments that are so small as to be effectively merely testing the library itself,[\[4\]](https://en.wikipedia.org/wiki/Test-driven_development#cite_note-Newkirk-4) unless there is some reason to believe that the library is buggy or is not sufficiently feature-complete to serve all the needs of the software under development.



